# Follower maze solution
This client-server application consists of two threads writing/reading the data to/from the same source.

##Client##

* The main responsibility of the client is to handle the users (be it online/offline).
* **ClientProcessor** is created to process the connected users.
* The **ClientProcessor** uses **UserRepository** to add/get/getAll users.
    
* ###### What can be improved in the future
    * Add unit test for happy path and edge cases.
    * Persist users (User model) to database.
    * Add DAOs.
      
##Server
* The main responsibility of the server is to handle the events generated by the **client** side.
* **EventProcessor<c>** is responsible for processing each event generated by a **Client**
* **EventProcessor** uses **EventFactory** to create a new event type based on the received payload.
* **EventProcessor** pushes the events created by the **EventFactory** to the **eventQueue** in order to run the 
processes concurrently and delegates the responsibility to the **QueueProcessor** to process the logic 
implemented for each event.
* The current solution can easily accommodate new event types by simply creating a new Builder which implements 
    **EventBuilder** and a new Event class which extends **BaseEvent**
    
* ###### What can be improved in the future
    * As the payload can change based on new event types in the future, it is recommended to use the *Builder Pattern*
     generate Data Transfer Objects (DTO) from the rawPayload, we could then separate the logic of the Events and the Payload
    * Unit tests are missing for both success case and edge cases therefore it is making it hard to refactor the 
    provided solution.
    * Acceptance tests could be also helpful here, potentially written in Gherkin specs


##Queue

There are two types of queues in the application **EventQueue** and **DeadLetterQueue**. 

Both queues are implementing an interface called **QueueInterface**.

* **EventQueue**
    * The main responsibility of the **EventQueue** is to process the main logic of the event pushed to the queue by 
    **QueueProcessor**.
    * The current queue saves all events in a **PriorityBlockingQueue**.
    * The main responsibility of the **DeadLetterQueue** is to process any malformed/offlineUser events, currently uses a 
    **PriorityBlockingQueue** to store them. 
    
* ###### What can be improved in the future
    * We should use message queues which implement the industry standard protocol *AMQP* such as 
    **AmazonSQS** | **RabbitMQ** | **Kafka** for our **EventQueue** and **DeadLetterQueue**
    * It is better to implement a configurable retry mechanism to retry failed events **n** times before pushing them to the DLQ
    * It is recommended to have a logging solution in place, allowing for simple error and performance monitoring
    * Please note that currently there is a slight performance issue, most likely caused by the number of Exception 
    objects thrown which is currently used for pushing events in the **DeadLetterQueue**. Given more time, a more elegant
    solution should be found.
